/*
Copyright 2024. projectsveltos.io. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sveltos_upgrade

import (
	"context"
	"fmt"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/go-logr/logr"

	libsveltosv1beta1 "github.com/projectsveltos/libsveltos/api/v1beta1"
	logs "github.com/projectsveltos/libsveltos/lib/logsettings"
)

// Sveltos agents evaluate classifiers, health checks, event sources, and reloader instances.
// Other Sveltos microservices in the management cluster rely on these evaluations.
// To ensure compatibility during upgrades, management cluster services should temporarily
// stop fetching evaluation results from agents until the agent's version matches the services' versions.
//
// Sveltos agents store their version in a ConfigMap, created in either the managed or management cluster
// depending on where the agent is running. Management cluster services then reference this ConfigMap to
// verify version compatibility, a crucial step when Sveltos CRD versions change during upgrades (e.g.,
// from v1alpha1 to v1beta1). Without this check, services might try to access newer CRD versions while
// agents and managed cluster CRDs are still using the older version.
//
// This same version compatibility logic also applies to the drift-detection-manager, which uses
// ResourceSummary to determine which resources to monitor for configuration drift.

// This package exposes methods to:
// - create/update ConfigMap
// - verify versions are compatible

// Following labels are added to any object created by Sveltos that needs to be
// processed or it is generated by Sveltos agents (ResourceSummary, Classifier, ClassifierReport,...)
// including the ConfigMaps used for compatibility checks.
const (
	ClusterNameLabel = "version.projectsveltos.io/clustername"
	ClusterTypeLabel = "version.projectsveltos.io/clustertype"
)

const (
	configMapNamespace          = "projectsveltos"
	sveltosAgentConfigMapName   = "sveltos-agent-version"
	driftDetectionConfigMapName = "drift-detection-version"
	configMapKey                = "version"
	agentTypeLabel              = "version.projectsveltos.io/agenttype"
	sveltosAgentType            = "sveltos-agent"
	driftDetectionType          = "drift-detection"
)

// IsSveltosAgentVersionCompatible returns true if Sveltos-agent running in a managed cluster is compatible
// with the provided version.

// It takes three arguments:
//   - ctx (context.Context): Context for the function call
//   - c (client.Client): Kubernetes client used to interact with the API server
// 	 - clusterNamespace, clusterName, clusterType identify the managed cluster
//   - version (string): Version to compare against the sveltos-agent version
//   - isAgentInMgmtMode indicates whether agents are in the management cluster (true) or managed clusters (false)

func IsSveltosAgentVersionCompatible(ctx context.Context, c client.Client, version, clusterNamespace, clusterName string,
	clusterType libsveltosv1beta1.ClusterType, isAgentInMgmtMode bool, logger logr.Logger) bool {

	cmInfo := getSveltosAgentConfigMapInfo(clusterNamespace, clusterName, clusterType, isAgentInMgmtMode)
	cm, err := getConfigMap(ctx, c, cmInfo, logger)
	if err != nil {
		return false
	}

	if cm.Data == nil {
		logger.V(logs.LogInfo).Info(fmt.Sprintf("configMap %v Data is empty", cmInfo))
		return false
	}

	if cm.Data[configMapKey] != version {
		logger.V(logs.LogInfo).Info(fmt.Sprintf("configMap %v current version %q. Expected version %q",
			cmInfo, cm.Data[configMapKey], version))
		return false
	}

	return true
}

// IsDriftDetectionVersionCompatible returns true if drift-detection-manager running in a managed cluster
// is compatible with the provided version.

// It takes three arguments:
//   - ctx (context.Context): Context for the function call
//   - c (client.Client): Kubernetes client used to interact with the API server
// 	 - clusterNamespace, clusterName, clusterType identify the managed cluster
//   - version (string): Version to compare against the sveltos-agent version
//   - isAgentInMgmtMode indicates whether agents are in the management cluster (true) or managed clusters (false)

func IsDriftDetectionVersionCompatible(ctx context.Context, c client.Client, version, clusterNamespace, clusterName string,
	clusterType libsveltosv1beta1.ClusterType, isAgentInMgmtMode bool, logger logr.Logger) bool {

	cmInfo := getDriftDetectionConfigMapInfo(clusterNamespace, clusterName, clusterType, isAgentInMgmtMode)
	cm, err := getConfigMap(ctx, c, cmInfo, logger)
	if err != nil {
		return false
	}

	if cm.Data == nil {
		logger.V(logs.LogInfo).Info(fmt.Sprintf("configMap %v Data is empty", cmInfo))
		return false
	}

	if cm.Data[configMapKey] != version {
		logger.V(logs.LogInfo).Info(fmt.Sprintf("configMap %v current version %q. Expected version %q",
			cmInfo, cm.Data[configMapKey], version))
		return false
	}

	return true
}

// StoreSveltosAgentVersion stores the provided Sveltos-agent version in a ConfigMap.
// It takes three arguments:
//   - ctx (context.Context): Context for the function call
//   - c (client.Client): Kubernetes client used to interact with the API server
//   - clusterNamespace, clusterName, clusterType identify the managed cluster
//   - version (string): Version to compare against the sveltos-agent version
//   - isAgentInMgmtMode indicates whether agents are in the management cluster (true) or managed clusters (false)
func StoreSveltosAgentVersion(ctx context.Context, c client.Client, version, clusterNamespace, clusterName string,
	clusterType libsveltosv1beta1.ClusterType, isAgentInMgmtMode bool, logger logr.Logger) error {

	lbls := getLabels(clusterName, clusterType)
	lbls[agentTypeLabel] = sveltosAgentType

	cmInfo := getSveltosAgentConfigMapInfo(clusterNamespace, clusterName, clusterType, isAgentInMgmtMode)
	cm, err := getConfigMap(ctx, c, cmInfo, logger)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return createConfigMap(ctx, c, version, cmInfo, lbls)
		}
		return err
	}

	cm.Labels = lbls
	if cm.Data == nil {
		cm.Data = map[string]string{}
	}
	cm.Data[configMapKey] = version
	return c.Update(ctx, cm)
}

// StoreDriftDetectionVersion stores the provided drift-detection-manager version in a ConfigMap.
// It takes three arguments:
//   - ctx (context.Context): Context for the function call
//   - c (client.Client): Kubernetes client used to interact with the API server
//   - clusterNamespace, clusterName, clusterType identify the managed cluster
//   - version (string): Version to compare against the sveltos-agent version
//   - isAgentInMgmtMode indicates whether agents are in the management cluster (true) or managed clusters (false)
func StoreDriftDetectionVersion(ctx context.Context, c client.Client, version, clusterNamespace, clusterName string,
	clusterType libsveltosv1beta1.ClusterType, isAgentInMgmtMode bool, logger logr.Logger) error {

	lbls := getLabels(clusterName, clusterType)
	lbls[agentTypeLabel] = driftDetectionType

	cmInfo := getDriftDetectionConfigMapInfo(clusterNamespace, clusterName, clusterType, isAgentInMgmtMode)
	cm, err := getConfigMap(ctx, c, cmInfo, logger)
	if err != nil {
		if apierrors.IsNotFound(err) {
			return createConfigMap(ctx, c, version, cmInfo, lbls)
		}
		return err
	}

	cm.Labels = lbls
	if cm.Data == nil {
		cm.Data = map[string]string{}
	}
	cm.Data[configMapKey] = version
	return c.Update(ctx, cm)
}

func createConfigMap(ctx context.Context, c client.Client, version string,
	info types.NamespacedName, lbls map[string]string) error {

	cm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Namespace: info.Namespace,
			Name:      info.Name,
			Labels:    lbls,
		},
		Data: map[string]string{
			configMapKey: version,
		},
	}
	return c.Create(ctx, cm)
}

func getConfigMap(ctx context.Context, c client.Client, cmInfo types.NamespacedName,
	logger logr.Logger) (*corev1.ConfigMap, error) {

	cm := &corev1.ConfigMap{}

	const timeout = 10 * time.Second
	ctxWithTimeout, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	logger.V(logs.LogDebug).Info(fmt.Sprintf("looking for ConfigMap %v", cmInfo))
	err := c.Get(ctxWithTimeout, cmInfo, cm)

	if err != nil {
		logger.V(logs.LogInfo).Info(fmt.Sprintf("failed to get configMap %v: %v", cmInfo, err))
		return nil, err
	}

	return cm, err
}

func getLabels(clusterName string, clusterType libsveltosv1beta1.ClusterType) map[string]string {
	return map[string]string{
		ClusterNameLabel: clusterName,
		ClusterTypeLabel: strings.ToLower(string(clusterType)),
	}
}

func generateName(agentType, clusterName string, clusterTpe libsveltosv1beta1.ClusterType) string {
	if agentType == sveltosAgentType {
		return fmt.Sprintf("sa-%s-%s", strings.ToLower(string(clusterTpe)), clusterName)
	}

	return fmt.Sprintf("dd-%s-%s", strings.ToLower(string(clusterTpe)), clusterName)
}

func getSveltosAgentConfigMapInfo(clusterNamespace, clusterName string, clusterType libsveltosv1beta1.ClusterType,
	isAgentInMgmtMode bool) types.NamespacedName {

	var namespace, name string
	if isAgentInMgmtMode {
		name = generateName(sveltosAgentType, clusterName, clusterType)
		namespace = clusterNamespace
	} else {
		name = sveltosAgentConfigMapName
		namespace = configMapNamespace
	}

	return types.NamespacedName{Namespace: namespace, Name: name}
}

func getDriftDetectionConfigMapInfo(clusterNamespace, clusterName string, clusterType libsveltosv1beta1.ClusterType,
	isAgentInMgmtMode bool) types.NamespacedName {

	var namespace, name string
	if isAgentInMgmtMode {
		name = generateName(driftDetectionType, clusterName, clusterType)
		namespace = clusterNamespace
	} else {
		name = driftDetectionConfigMapName
		namespace = configMapNamespace
	}

	return types.NamespacedName{Namespace: namespace, Name: name}
}
